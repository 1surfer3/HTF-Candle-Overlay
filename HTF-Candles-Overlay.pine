// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © 

//@version=6
indicator("HTF Candles Overlay - Multi-Timeframe", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=1)

// ===================================
// 1. INPUT SETTINGS (HTF and Visuals)
// ===================================

// Higher Timeframe Selection (15m, 30m, 1H, 4H, 1D, 1W)
i_htf_choice = input.string(title="Select Higher Timeframe (HTF)", defval="1H", options=["15m", "30m", "1H", "4H", "1D", "1W"], group="HTF Settings")

// Map user selection to Pine Script timeframe format
htfTimeframe = switch i_htf_choice
    "15m" => "15"
    "30m" => "30"
    "1H"  => "60"
    "4H"  => "240"
    "1D"  => "D"
    "1W"  => "W"
    => "60" // Default to 1H

// VISUAL SETTINGS
bullishColor = input.color(color.new(color.black, 90), "Bullish Body Fill (Black)") 
bearishColor = input.color(color.new(color.black, 90), "Bearish Body Fill (Black)")   
bullishBorderColor = input.color(color.new(color.blue, 10), "Bullish Border & Wick (Blue)") 
bearishBorderColor = input.color(color.new(color.red, 10), "Bearish Border & Wick (Red)") 
wickWidth = input.int(2, "Wick Width", minval=1, maxval=5) 
borderWidth = input.int(3, "Border Width", minval=1, maxval=5)
showBorders = input.bool(true, "Show Borders")

// History settings
candlesToShow = input.int(40, "Number of Candles to Display", minval=1, maxval=100) 

// Countdown settings
showCountdown = input.bool(true, "Show Countdown", group="Countdown")
countdownSize = input.string("normal", "Label Size", options=["tiny", "small", "normal", "large", "huge"], group="Countdown")
countdownColor = input.color(color.new(color.white, 0), "Text Color", group="Countdown")
countdownBgColor = input.color(color.new(color.blue, 20), "Background Color", group="Countdown")

// ===================================
// 2. DATA AND DRAWING ARRAYS
// ===================================

// Arrays to hold drawing objects (boxes and lines) for efficient deletion/redrawing
var array<box> candleBodies = array.new<box>()
var array<line> upperWicks = array.new<line>()
var array<line> lowerWicks = array.new<line>()
var label countdownLabel = na

// Request HTF data using the selected timeframe. `lookahead=barmerge.lookahead_off` 
// is essential for correct real-time data handling.
htfOpen = request.security(syminfo.tickerid, htfTimeframe, open, lookahead=barmerge.lookahead_off)
htfHigh = request.security(syminfo.tickerid, htfTimeframe, high, lookahead=barmerge.lookahead_off)
htfLow = request.security(syminfo.tickerid, htfTimeframe, low, lookahead=barmerge.lookahead_off)
htfClose = request.security(syminfo.tickerid, htfTimeframe, close, lookahead=barmerge.lookahead_off)
htfTime = request.security(syminfo.tickerid, htfTimeframe, time, lookahead=barmerge.lookahead_off)

// Function to format remaining time into H:M:S string
formatTime(milliseconds) =>
    seconds = milliseconds / 1000
    minutes = math.floor(seconds / 60) 
    remainingSeconds = math.floor(seconds % 60)
    hours = math.floor(minutes / 60)
    remainingMinutes = math.floor(minutes % 60)
    
    timeStr = ""
    if hours > 0
        timeStr := str.tostring(hours) + "h " + str.tostring(remainingMinutes) + "m " + str.tostring(remainingSeconds) + "s"
    else if remainingMinutes > 0
        timeStr := str.tostring(remainingMinutes) + "m " + str.tostring(remainingSeconds) + "s"
    else
        timeStr := str.tostring(remainingSeconds) + "s"
    timeStr

// Function to map input string to Pine Script label size object
getLabelSize(sizeStr) =>
    switch sizeStr
        "tiny" => size.tiny
        "small" => size.small
        "normal" => size.normal
        "large" => size.large
        "huge" => size.huge
        => size.normal

// ===================================
// 3. DRAWING FUNCTION
// ===================================

drawCandle(startTime, candleOpen, candleHigh, candleLow, candleClose) =>
    // Calculate the duration of the HTF period in milliseconds
    htfPeriodMs = timeframe.in_seconds(htfTimeframe) * 1000 
    boxRight = startTime + htfPeriodMs
    
    isBullish = candleClose >= candleOpen
    
    boxColor = isBullish ? bullishColor : bearishColor 
    borderColor = isBullish ? bullishBorderColor : bearishBorderColor
    wickColorFinal = borderColor
    
    bodyTop = math.max(candleOpen, candleClose) 
    bodyBottom = math.min(candleOpen, candleClose) 
    
    // Calculate the base middle point (in time) for the wick
    wickX_base = startTime + htfPeriodMs / 2 
    
    // CRITICAL FIX: Conditional offset for 1W timeframe alignment issue 
    // This compensates for a known rendering bug in TradingView when using xloc.bar_time on Weekly.
    wickX_offset = 0
    if htfTimeframe == "W"
        // Offset by 1 day (86,400,000 ms) leftward
        wickX_offset := -86400000 
    
    // Final wick X position
    wickX = wickX_base + wickX_offset
    
    // Create candle body box
    bodyBox = box.new(
             left=startTime,
             top=bodyTop,
             right=boxRight,
             bottom=bodyBottom,
             bgcolor=boxColor,
             border_color=showBorders ? borderColor : na,
             border_width=borderWidth, 
             border_style=line.style_solid,
             xloc=xloc.bar_time
          )
    
    // Create upper wick
    upperWick = line(na)
    if candleHigh > bodyTop
        upperWick := line.new(
                 x1=wickX, // Use corrected X
                 y1=bodyTop,
                 x2=wickX,
                 y2=candleHigh,
                 color=wickColorFinal,
                 width=wickWidth, 
                 xloc=xloc.bar_time 
              )
    
    // Create lower wick
    lowerWick = line(na)
    if candleLow < bodyBottom
        lowerWick := line.new(
                 x1=wickX, // Use corrected X
                 y1=bodyBottom,
                 x2=wickX,
                 y2=candleLow,
                 color=wickColorFinal,
                 width=wickWidth, 
                 xloc=xloc.bar_time 
              )
    
    [bodyBox, upperWick, lowerWick]

// ===================================
// 4. MAIN EXECUTION LOGIC
// ===================================

// Function to clear all previously drawn objects
clearAllDrawings() =>
    if array.size(candleBodies) > 0
        for i = 0 to array.size(candleBodies) - 1
            box.delete(array.get(candleBodies, i))
        array.clear(candleBodies)
    
    if array.size(upperWicks) > 0
        for i = 0 to array.size(upperWicks) - 1
            if not na(array.get(upperWicks, i))
                line.delete(array.get(upperWicks, i))
        array.clear(upperWicks)
    
    if array.size(lowerWicks) > 0
        for i = 0 to array.size(lowerWicks) - 1
            if not na(array.get(lowerWicks, i))
                line.delete(array.get(lowerWicks, i))
        array.clear(lowerWicks)

// Initialize persistent arrays to store HTF candle data
var array<float> storedOpen = array.new<float>()
var array<float> storedHigh = array.new<float>()
var array<float> storedLow = array.new<float>()
var array<float> storedClose = array.new<float>()
var array<int> storedTime = array.new<int>()
var int lastStoredTime = na

// Check if a new HTF candle has started
bool newHTFCandle = na(lastStoredTime) or htfTime != lastStoredTime

if newHTFCandle and not na(htfTime)
    lastStoredTime := htfTime
    
    // Store new candle data at the front of the arrays
    array.unshift(storedOpen, htfOpen)
    array.unshift(storedHigh, htfHigh)
    array.unshift(storedLow, htfLow)
    array.unshift(storedClose, htfClose)
    array.unshift(storedTime, htfTime)
    
    // Trim arrays to keep only the requested number of candles
    if array.size(storedOpen) > candlesToShow
        array.pop(storedOpen)
        array.pop(storedHigh)
        array.pop(storedLow)
        array.pop(storedClose)
        array.pop(storedTime)
else
    // Update the data for the current (newest) candle
    if array.size(storedOpen) > 0
        array.set(storedOpen, 0, htfOpen)
        array.set(storedHigh, 0, htfHigh)
        array.set(storedLow, 0, htfLow)
        array.set(storedClose, 0, htfClose)

// Draw all candles on the last bar of the chart (efficient drawing)
if barstate.islast or barstate.isrealtime
    clearAllDrawings()
    
    // Loop through stored HTF candle data and draw
    for i = 0 to math.min(array.size(storedTime) - 1, candlesToShow - 1) 
        candleTime = array.get(storedTime, i)
        candleOpen = array.get(storedOpen, i)
        candleHigh = array.get(storedHigh, i)
        candleLow = array.get(storedLow, i)
        candleClose = array.get(storedClose, i)
        
        [bodyBox, upperWick, lowerWick] = drawCandle(candleTime, candleOpen, candleHigh, candleLow, candleClose)
        
        array.push(candleBodies, bodyBox)
        array.push(upperWicks, upperWick)
        array.push(lowerWicks, lowerWick)

// Update countdown timer label
if showCountdown and not na(htfTime) and array.size(storedTime) > 0
    htfPeriodMs = timeframe.in_seconds(htfTimeframe) * 1000 
    nextCandleTime = htfTime + htfPeriodMs
    
    currentTimeMs = timenow
    timeRemaining = nextCandleTime - currentTimeMs
    
    if timeRemaining > 0
        countdownText = formatTime(timeRemaining)
        
        latestCandleTime = array.get(storedTime, 0)
        latestHigh = array.get(storedHigh, 0)
        
        if not na(countdownLabel)
            label.delete(countdownLabel)
        
        countdownLabel := label.new(
                 x=latestCandleTime + (htfPeriodMs / 2),
                 y=latestHigh,
                 text=countdownText,
                 style=label.style_label_down, 
                 color=countdownBgColor,
                 textcolor=countdownColor,
                 size=getLabelSize(countdownSize),
                 xloc=xloc.bar_time,
                 yloc=yloc.price
              )
else if not showCountdown and not na(countdownLabel)
    label.delete(countdownLabel)
    countdownLabel := na
